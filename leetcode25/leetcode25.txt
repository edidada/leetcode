[leetcode25 csdn ](https://blog.csdn.net/NoMasp/article/details/49815131)

给定一个链表，在一定时间内反转这个链表的结点，并返回修改后的链表。

如果结点数不是K的倍数，那么剩余的结点就保持原样。

你不应该在结点上修改它的值，只有结点自身可以修改。

只允许使用常量空间。

例如

给定链表： 1->2->3->4->5

对于 k = 2，你应该返回： 2->1->4->3->5

对于 k = 3，你应该返回： 3->2->1->4->5



Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5



```c++
class Solution {
public:
  ListNode* reverseKGroup(ListNode *head, int k) {
    ListNode *current = head;
    for (int i = 0; i < k; ++i) {
      if (!current) return head;
      current = current->next;
    }
    ListNode *newHead = reverse(head, current);
    head->next = reverseKGroup(current, k);
    return newHead;
  }

  ListNode* reverse(ListNode *start, ListNode *end) {
    ListNode *head = end;
    while (start != end) {
      ListNode *tmp = start->next;
      start->next = head;
      head = start;
      start = tmp;
    }
    return head;
  }
};
```
